<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XJW&#39;s Blog</title>
  
  <subtitle>From small beginning come great things</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.xiejiawei.cc/"/>
  <updated>2018-10-06T05:19:32.386Z</updated>
  <id>https://www.xiejiawei.cc/</id>
  
  <author>
    <name>谢嘉威</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python漫谈-0</title>
    <link href="https://www.xiejiawei.cc/2018/10/06/python-talk-0/"/>
    <id>https://www.xiejiawei.cc/2018/10/06/python-talk-0/</id>
    <published>2018-10-06T03:06:02.000Z</published>
    <updated>2018-10-06T05:19:32.386Z</updated>
    
    <content type="html"><![CDATA[<p>​                                                                     <a href="//www.zhihu.com/people/a-kun-99-10"><img src="/2018/10/06/python-talk-0/avatar.jpg" alt="Mikejiawei"></a></p><p>Hello,又和大家见面了。最近国庆放假终于可以腾开手写我的博客啦！ ^_^!</p><hr><p>​    <strong>Python 漫谈系列</strong> 是笔者对于过往 python 学习的总结和对新知识的记录。这个系列将见证本人的成长，<em>希望能一直保持更新</em></p><a id="more"></a><p>废话说完了，现在开始正文。</p><p>​    <a href="https://www.python.org/" title="Python" target="_blank" rel="noopener">Python</a> 是一门脚本语言，详见官方文档。它的应用范围十分广泛，涉足<strong>Web应用开发</strong>，<strong>系统网络运维</strong>，<strong>科学与数字运算</strong>，<strong>3D游戏开发</strong>，<strong>网络编程</strong>，等等。足见其灵活性与强大性。</p><p>​    由此可见，python 不局限于一个简单的脚本，或者写一个爬虫，文件处理。它有许多神奇等着我们去挖掘！本篇为开篇，简单介绍一下 <strong>Python</strong> 的变量和字符串。</p><hr><p>【注】</p><ul><li><p><em>此系列主要是总结，会结合一些案例与题目。</em> </p></li><li><p><a href="https://docs.python.org/3/library/idle.html" title="IDLE" target="_blank" rel="noopener">IDLE</a></p></li></ul><hr><h1 id="python中的变量"><a href="#python中的变量" class="headerlink" title="python中的变量"></a>python中的变量</h1><h2 id="python数据类型"><a href="#python数据类型" class="headerlink" title="python数据类型"></a>python数据类型</h2><p>说到<strong>python</strong>中的常量，不得不说它的<strong>数据类型</strong>，其分为 哈希类型、不可哈希类型。</p><p><strong>哈希类型</strong>，即在原地不能改变的变量类型，不可变类型。可利用hash函数查看器hash值，也可以作为字典的key   </p><ul><li>“ 数字类型 ： int, float, decimal.Decimal, fractions.Fraction, complex “</li><li>“ 字符串类型 ：str, bytes  “</li><li>“ 元组 ：tuple  “</li><li>“ 冻结集合 ：frozenset “</li><li>“ 布尔类型 ：True，False “</li><li>“ None “</li></ul><p><strong>不可哈希类型</strong>，原地可变类型：list、dict 和 set，它们不可以作为字典的key。</p><h2 id="python中的变量-1"><a href="#python中的变量-1" class="headerlink" title="python中的变量"></a>python中的变量</h2><p>接触过其它语言的人都知道，把一个值赋值给一个变量名时，Ta会存储在内存中，我们称其为变量。在大多数语言当中，都把这种行为称作“给变量赋值”。</p><p>不过 Python 与大多数其它计算机语言的做法稍有不同， Ta并不是把值储存在变量中， 而更像是把名字贴在值的上边，<strong>接触过C/C++的知道这其实是指针</strong></p><p><strong>举个栗子</strong></p><blockquote><p><code>int</code> 类型在python中是动态长度的。因为python3中 int 类型是长整型，理论支持无限大的数字，但它的结构其实也很简单, 在 <code>longintepr.h</code> 中定义： </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct _longobject &#123;</span><br><span class="line">  PyObject_VAR_HEAD</span><br><span class="line">  digi ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这结构是什么意思呢，重点在于 <code>ob_digit</code> 它是一个数组指针。<code>digit</code> 可认为是 <code>int</code> 的别名。python的整型存储机制是这样的。比方要表示一个很大的数: <code>123456789</code> 。而每个元素最大只能表示3位十进制数（为理解打的比方）。那么python就会这样存储：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ob_digit[<span class="number">0</span>] = <span class="number">789</span></span><br><span class="line">ob_digit[<span class="number">1</span>] = <span class="number">456</span></span><br><span class="line">ob_digit[<span class="number">2</span>] = <span class="number">123</span></span><br></pre></td></tr></table></figure><h1 id="Python-中的字符串"><a href="#Python-中的字符串" class="headerlink" title="Python 中的字符串"></a>Python 中的字符串</h1><ul><li><p>例子：<strong>试试直接输入 &gt;&gt;&gt;5+8 与输入 &gt;&gt;&gt;print(5+8) 有何不同？</strong>  </p><p>不妨试试直接直接输入 &gt;&gt;&gt;’I love python!’ 与输入 &gt;&gt;&gt;print(‘I love python!’) 有何不同？ 没错，直接输入是将结果及类型打印到屏幕上，而print是将结果打印到屏幕上。</p></li></ul><p>没错python中的字符串是一个比较有意思的东西，举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#常见字符串常量和表达式</span></span><br><span class="line">S = <span class="string">''</span><span class="comment"># 空字符串</span></span><br><span class="line">S = <span class="string">" spam's "</span><span class="comment"># 双引号 和单引号相同</span></span><br><span class="line">S = <span class="string">"s\np\ta\x00m"</span>  <span class="comment"># 转义字符</span></span><br><span class="line">S = <span class="string">r'\temp'</span><span class="comment">#raw字符串，抑制转义，但是末尾不能+\</span></span><br><span class="line"><span class="comment">#如果要在末尾加\ 可以选择拼接一个 ^-^!</span></span><br><span class="line">S = <span class="string">b'Spam'</span><span class="comment">#Python3 中的字节字符串</span></span><br><span class="line">s1+s2, s1*<span class="number">3</span>, s[i], s[i:j], len(s) <span class="comment">#字符串操作</span></span><br><span class="line"><span class="comment">#另类字符串拼接</span></span><br><span class="line">name = <span class="string">"da"</span><span class="string">"han"</span><span class="comment">#单行， name = "dahan"</span></span><br><span class="line">name = <span class="string">"da"</span> \<span class="comment">#多行， name = "dahan"</span></span><br><span class="line"><span class="string">"han"</span></span><br><span class="line"><span class="comment">#多行字符串块</span></span><br><span class="line">m = <span class="string">"""hello world</span></span><br><span class="line"><span class="string">   hello html</span></span><br><span class="line"><span class="string">   hello python</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p><strong>其实python中的字符串妙用和功能还有很多，这里这是浅显的介绍一下，以后在项目中我会有所体现的哦！</strong></p><hr><ul><li>因为笔者是初学者尚有许多不足，欢迎各位观众姥爷批评指正。</li><li>希望此系列能越写越好 QAQ</li></ul><p><img src="/2018/10/06/python-talk-0/python.png" alt="python"></p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​                                                                     &lt;a href=&quot;//www.zhihu.com/people/a-kun-99-10&quot;&gt;&lt;img src=&quot;/2018/10/06/python-talk-0/avatar.jpg&quot; alt=&quot;Mikejiawei&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hello,又和大家见面了。最近国庆放假终于可以腾开手写我的博客啦！ ^_^!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;​    &lt;strong&gt;Python 漫谈系列&lt;/strong&gt; 是笔者对于过往 python 学习的总结和对新知识的记录。这个系列将见证本人的成长，&lt;em&gt;希望能一直保持更新&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python学习" scheme="https://www.xiejiawei.cc/categories/python%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="https://www.xiejiawei.cc/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>三种常用的排序算法</title>
    <link href="https://www.xiejiawei.cc/2018/08/21/%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://www.xiejiawei.cc/2018/08/21/三种常用的排序算法/</id>
    <published>2018-08-20T16:22:53.000Z</published>
    <updated>2018-10-05T01:50:47.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三种常用的排序算法"><a href="#三种常用的排序算法" class="headerlink" title="三种常用的排序算法"></a>三种常用的排序算法</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><em>笔者</em> 是一名在校大学生，在学校常用的算法有很多，<strong>毕竟算法是程序的灵魂</strong> ，我就整理一点算法笔记放在博客上以供参考。<em>PS: Java版本</em></p><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul><li><p>平均时间复杂度：O(n^2)</p></li><li><p>稳定性：稳定[^1]</p></li><li><p>排序算法的稳定性(<em>腾讯校招2016笔试题曾考过</em>)</p><blockquote><p>冒泡排序是一种极其简单的排序算法，也是我所学的第一个排序算法。它重复地走访过要排序的元素，依此比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。 </p></blockquote><p><strong>代码如下</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义临时变量</span></span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++)&#123; <span class="comment">//对n个数排序只要交换n-1次即可</span></span><br><span class="line">            <span class="comment">//外层循环，每次把最大的元素像气泡一样“浮”到数组的最后</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt;arr.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//内层循环</span></span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123; <span class="comment">//依此比较相邻的两个元素，使较大的那个向后移</span></span><br><span class="line"><span class="comment">//三变量交换法</span></span><br><span class="line">                      p = arr[j];</span><br><span class="line">arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>] = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">28</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">bubbleSort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果如下</strong> </p><blockquote><p>[1, 3, 4, 5, 6, 7, 7, 8, 28]</p><a id="more"></a></blockquote></li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li><p>平均时间复杂度：O(n^2)</p></li><li><p>稳定性：不稳定</p><blockquote><p>选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>　　注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。</p></blockquote><p><strong>代码如下：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">//i 为已排序序列的末尾 </span></span><br><span class="line">             <span class="keyword">int</span> k = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j= i+<span class="number">1</span>;j&lt;arr.length;j++) &#123;<span class="comment">//未排序序列</span></span><br><span class="line"><span class="keyword">if</span> (arr[k]&gt;arr[j]) &#123;<span class="comment">//找出未排序序列中的最小值</span></span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i!=k) &#123;<span class="comment">//放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[k];</span><br><span class="line">arr[k] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[ ] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">28</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">selectionSort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果如下：</strong> </p><blockquote><p>[1, 3, 4, 5, 6, 7, 8, 11, 28]</p></blockquote></li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li><p>平均时间复杂度：O(nlogn)</p></li><li><p>稳定性：不稳定</p></li><li><p><strong>快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。</strong> </p><blockquote><p>​    快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要$O(nlog n)$次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他$O(nlog n)$ 算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。</p><p>　　快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：</p><ol><li>从序列中挑出一个元素，作为”基准”(pivot).</li><li>把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。</li><li>对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。</li></ol></blockquote></li></ul><p><strong>快速排序的代码如下：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快速排序的递归版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大等于endIndex的时候</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分递归排序</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取第一个位置的元素作为基准元素</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="comment">//控制right指针比较并左移</span></span><br><span class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//控制left指针比较并右移</span></span><br><span class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换left和right指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = arr[left];</span><br><span class="line">                arr[left]  = arr[right];</span><br><span class="line">                arr[right] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pivot和指针重合点交换</span></span><br><span class="line">        <span class="keyword">int</span> p = arr[left];</span><br><span class="line">        arr[left]  = arr[startIndex];</span><br><span class="line">        arr[startIndex] = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">28</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果如下：</strong></p><blockquote><p>[1, 3, 4, 5, 6, 7, 7, 8, 28]</p></blockquote><ul><li><p><strong>快速排序的非递归实现：</strong></p><blockquote><p>绝大多数用递归来实现的问题，都可以用【栈】的方式来代替。</p><p>因为我们代码中一层一层的方法调用，本身就是一个函数栈。每次进入一个新方法，就相当于入栈；每次有方法返回，就相当于出栈。</p><p>所以，我们可以把原本的递归实现转化成一个栈的实现，在栈当中存储每一次方法调用的参数。</p></blockquote><p>  <strong>代码如下：</strong> </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSortWithStack</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//  用一个集合栈来代替递归的函数栈</span></span><br><span class="line">        Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="keyword">new</span> Stack&lt;Map&lt;String, Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">//  整个数列的起止下标，以哈希的形式入栈</span></span><br><span class="line">        Map rootParam = <span class="keyword">new</span> HashMap();</span><br><span class="line">        rootParam.put(<span class="string">"startIndex"</span>, startIndex);</span><br><span class="line">        rootParam.put(<span class="string">"endIndex"</span>, endIndex);</span><br><span class="line">        quickSortStack.push(rootParam);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环结束条件： 栈为空时结束</span></span><br><span class="line">        <span class="keyword">while</span>(!quickSortStack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//栈顶元素出栈，得到起止下标</span></span><br><span class="line">            Map&lt;String, Integer&gt; param = quickSortStack.pop();</span><br><span class="line">            <span class="comment">//得到基准元素位置</span></span><br><span class="line">            <span class="keyword">int</span> pivotIndex  = partition(arr, param.get(<span class="string">"startIndex"</span>), param.get(<span class="string">"endIndex"</span>));</span><br><span class="line">            <span class="comment">//根据基准元素分成两部分，把每一部分的起止下标入栈</span></span><br><span class="line">            <span class="keyword">if</span> (param.get(<span class="string">"startIndex"</span>)&lt; pivotIndex -<span class="number">1</span>) &#123;</span><br><span class="line">                Map&lt;String, Integer&gt; leftParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">                leftParam.put(<span class="string">"startIndex"</span>, param.get(<span class="string">"startIndex"</span>));</span><br><span class="line">                leftParam.put(<span class="string">"endIndex"</span>, pivotIndex -<span class="number">1</span>);</span><br><span class="line">                quickSortStack.push(leftParam);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pivotIndex + <span class="number">1</span> &lt; param.get(<span class="string">"endIndex"</span>)) &#123;</span><br><span class="line">                Map&lt;String, Integer&gt; rightParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">                rightParam.put(<span class="string">"startIndex"</span>, pivotIndex + <span class="number">1</span>);</span><br><span class="line">                rightParam.put(<span class="string">"endIndex"</span>, param.get(<span class="string">"endIndex"</span>));</span><br><span class="line">                quickSortStack.push(rightParam);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取第一个位置的元素作为基准元素</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="comment">//控制right指针比较并左移</span></span><br><span class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//控制left指针比较并右移</span></span><br><span class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换left和right指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = arr[left];</span><br><span class="line">                arr[left]  = arr[right];</span><br><span class="line">                arr[right] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pivot和指针重合点交换</span></span><br><span class="line">        <span class="keyword">int</span> p = arr[left];</span><br><span class="line">        arr[left]  = arr[startIndex];</span><br><span class="line">        arr[startIndex] = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>运行结果如下：</strong></p><blockquote><p>[1, 2, 3, 4, 5, 6, 7, 8]</p></blockquote></li></ul><pre><code>---## 结语：emmm，常用的排序算法就介绍到这里，如有错漏之处，或者有疑问可联系笔者，愿一起进步。Email： 15270013718@163.com</code></pre><p>  [^1]: <strong>如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。</strong>  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;三种常用的排序算法&quot;&gt;&lt;a href=&quot;#三种常用的排序算法&quot; class=&quot;headerlink&quot; title=&quot;三种常用的排序算法&quot;&gt;&lt;/a&gt;三种常用的排序算法&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;em&gt;笔者&lt;/em&gt; 是一名在校大学生，在学校常用的算法有很多，&lt;strong&gt;毕竟算法是程序的灵魂&lt;/strong&gt; ，我就整理一点算法笔记放在博客上以供参考。&lt;em&gt;PS: Java版本&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;平均时间复杂度：O(n^2)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;稳定性：稳定[^1]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;排序算法的稳定性(&lt;em&gt;腾讯校招2016笔试题曾考过&lt;/em&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;冒泡排序是一种极其简单的排序算法，也是我所学的第一个排序算法。它重复地走访过要排序的元素，依此比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;代码如下&lt;/strong&gt; &lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.Arrays;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BubbleSort&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bubbleSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//定义临时变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;arr.length-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i++)&amp;#123; &lt;span class=&quot;comment&quot;&gt;//对n个数排序只要交换n-1次即可&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//外层循环，每次把最大的元素像气泡一样“浮”到数组的最后&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j&amp;lt;arr.length-i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//内层循环&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(arr[j]&amp;gt;arr[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&amp;#123; &lt;span class=&quot;comment&quot;&gt;//依此比较相邻的两个元素，使较大的那个向后移&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&lt;span class=&quot;comment&quot;&gt;//三变量交换法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      p = arr[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					arr[j] = arr[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					arr[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] &amp;#123;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		bubbleSort(arr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(Arrays.toString(arr));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;运行结果如下&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[1, 3, 4, 5, 6, 7, 7, 8, 28]&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://www.xiejiawei.cc/categories/Algorithm/"/>
    
    
      <category term="Java入门" scheme="https://www.xiejiawei.cc/tags/Java%E5%85%A5%E9%97%A8/"/>
    
      <category term="算法" scheme="https://www.xiejiawei.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>类与对象</title>
    <link href="https://www.xiejiawei.cc/2018/06/05/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.xiejiawei.cc/2018/06/05/类与对象/</id>
    <published>2018-06-04T16:54:47.000Z</published>
    <updated>2018-10-05T03:16:39.032Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/06/05/类与对象/01title.jpg" alt=" "></p><h1 id="当大一萌新遇上Java系列——浅谈Java中的类与对象"><a href="#当大一萌新遇上Java系列——浅谈Java中的类与对象" class="headerlink" title="当大一萌新遇上Java系列——浅谈Java中的类与对象"></a>当大一萌新遇上Java系列——浅谈Java中的类与对象</h1><p><a href="//www.zhihu.com/people/a-kun-99-10">Mikejiawei</a></p><p>笔者是一名大一新生，虽久闻Java大名，却不识庐山真面目，最近才开始接触Java这门语言。</p><ul><li>Java作为一种流行的语言，自有其可取之处，毕竟它有可以跨平台运行的优点，被众多厂商支持，以及拥有众多的开发工具。</li></ul><p>当然作为一个程序猿吐槽自己用的语言是常见的消遣方式?,例如</p><blockquote><p>JAVA truly is the great equalizing software. It has reduced all computers to mediocrity and buggyness. - NASA’s J-Track web site（Java是一个真正注重平等权的软件，它将所有的电脑（不管配置有多好）统统变成平庸的以及有bug的电脑。- NASA’s J-Track web site）<br>Whenever I write code in Java I feel like I’m filling out endless forms in triplicate. – Joe Marshall (aka jrm)（每当我在Java中写代码时，我都觉得我在填写一式三份的表格 – Joe Marshall）</p></blockquote><p>言归正传，Java作为一种面向对象的语言，顾名思义就是把构成问题事物分解成各个对象，并描述对象在解决整个问题的步骤中的状态和行为。这与C等面向过程的语言不同，有着不同的解决问题的方式。今天我们谈的是java中的“类与对象”。<br><a id="more"></a></p><p>以下正文</p><hr><ul><li><strong>如何理解“类与对象”</strong></li></ul><p>“类”就是一类事物，是某些有相同特性的事物的集合、总称；例如人类，鱼类，鸟类等。</p><p>”对象“指的是”这一类事物中具体的一个东西“，如一个叫李四的人就是人类中的一个对象，学生李就是学生类中的一个对象，由此可见”类“是一个较为抽象，笼统的概念，对象则更为具体。</p><p>在这里大概有人会问了：</p><p>Q：电子产品类里，手机是其中一个对象，但手机也有很多种，那手机是类还是对象呢？</p><p>A：在电子产品类中，手机是一个对象。当然手机也可以是一个手机类，包括了华为手机，苹果手机这些手机对象。所以类与对象其实是个相对的关系，理解这一点，对以后我们学习继承，接口，理解子父类有很大帮助。（嘿嘿嘿~）</p><p><em><strong>PS:在现实生活中我们可以根据不同的场景来编写不同的类以解决问题，比如你要给你的朋友写个关于空调的程序，那就建一个空调类，在运用海尔，美的空调等对象。</strong></em></p><ul><li><strong>格式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">drawPanel</span></span>&#123;</span><br><span class="line">    MyFrame drawFrame = <span class="keyword">new</span> MyFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意具体格式来了：</li></ul><p>public class 类名{</p><p>类名 对象名 = new 类名( );</p><p>}</p><p>注意括号和分号都要用英文格式，不然会报错。</p><ul><li><strong>属性和方法</strong></li></ul><p>大家发现，上图中除了类与对象还有一些其他的东西，那就是属性和方法。</p><p>“属性”就是类所具备的特征，比如学生类具有”姓名，班级，学分，年龄“等各种各样的属性。</p><p>”方法“就是对象需要执行的动作，比如”学习，吃饭，睡觉，运动“。</p><ul><li>属性和方法的格式</li></ul><p>属性：</p><p>public 数据类型 数据名；</p><p>如public String name；</p><p>上面指的的数据类型有：整形，浮点型（小数），字符串等等；有其对应的英文比如：整数（int），小数（float）。</p><p>方法：</p><p>pubic void 方法名（参数）{</p><p>方法体</p><p>}</p><ul><li>结束语</li></ul><p><em>欢迎各位从入门到入土的Java工程师们和小伙伴们留言，一起交流学习，文中有错漏之处也欢迎批评指出，人生不能没有bug嘛（哈哈~）</em></p><p><em>希望在这条道路上越走越远，下次再见ヾ(￣▽￣)Bye~Bye~</em></p><p><img src="/2018/06/05/类与对象/0102.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/06/05/类与对象/01title.jpg&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;当大一萌新遇上Java系列——浅谈Java中的类与对象&quot;&gt;&lt;a href=&quot;#当大一萌新遇上Java系列——浅谈Java中的类与对象&quot; class=&quot;headerlink&quot; title=&quot;当大一萌新遇上Java系列——浅谈Java中的类与对象&quot;&gt;&lt;/a&gt;当大一萌新遇上Java系列——浅谈Java中的类与对象&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;//www.zhihu.com/people/a-kun-99-10&quot;&gt;Mikejiawei&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;笔者是一名大一新生，虽久闻Java大名，却不识庐山真面目，最近才开始接触Java这门语言。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java作为一种流行的语言，自有其可取之处，毕竟它有可以跨平台运行的优点，被众多厂商支持，以及拥有众多的开发工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然作为一个程序猿吐槽自己用的语言是常见的消遣方式?,例如&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JAVA truly is the great equalizing software. It has reduced all computers to mediocrity and buggyness. - NASA’s J-Track web site（Java是一个真正注重平等权的软件，它将所有的电脑（不管配置有多好）统统变成平庸的以及有bug的电脑。- NASA’s J-Track web site）&lt;br&gt;Whenever I write code in Java I feel like I’m filling out endless forms in triplicate. – Joe Marshall (aka jrm)（每当我在Java中写代码时，我都觉得我在填写一式三份的表格 – Joe Marshall）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;言归正传，Java作为一种面向对象的语言，顾名思义就是把构成问题事物分解成各个对象，并描述对象在解决整个问题的步骤中的状态和行为。这与C等面向过程的语言不同，有着不同的解决问题的方式。今天我们谈的是java中的“类与对象”。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.xiejiawei.cc/categories/Java/"/>
    
    
      <category term="Java入门" scheme="https://www.xiejiawei.cc/tags/Java%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
