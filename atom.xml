<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XJW&#39;s Blog</title>
  
  <subtitle>From small beginning come great things</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.xiejiawei.cc/"/>
  <updated>2019-02-19T09:23:41.560Z</updated>
  <id>https://www.xiejiawei.cc/</id>
  
  <author>
    <name>谢嘉威</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链表</title>
    <link href="https://www.xiejiawei.cc/2019/02/19/%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.xiejiawei.cc/2019/02/19/链表/</id>
    <published>2019-02-19T08:23:31.000Z</published>
    <updated>2019-02-19T09:23:41.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是链表？"><a href="#一、什么是链表？" class="headerlink" title="一、什么是链表？"></a>一、什么是链表？</h2><ol><li>和数组一样，链表也是一种线性表。</li><li>从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。</li><li>链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。<a id="more"></a><h2 id="二、链表的特点"><a href="#二、链表的特点" class="headerlink" title="二、链表的特点"></a>二、链表的特点</h2></li><li>插入、删除数据效率高，为O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。</li><li>和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。<h2 id="三、常用链表：单链表、循环链表和双向链表"><a href="#三、常用链表：单链表、循环链表和双向链表" class="headerlink" title="三、常用链表：单链表、循环链表和双向链表"></a>三、常用链表：单链表、循环链表和双向链表</h2></li></ol><ul><li><strong>单链表</strong><br><img src="/2019/02/19/链表/linkedlist1.jpg" alt="enter description here"><br>1）每个节点只包含一个指针，即后继指针。<br>2）单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。<br>3）性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。</li><li><strong>循环链表</strong><br><img src="/2019/02/19/链表/linkedlist2.jpg" alt="enter description here"><br>1）除了尾节点的后继指针指向首节点的地址外均与单链表一致。<br>2）适用于存储有循环特点的数据，比如约瑟夫问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//约瑟夫环运作如下：</span></span><br><span class="line"><span class="comment">//1、一群人围在一起坐成环状（如：N）</span></span><br><span class="line"><span class="comment">//2、从某个编号开始报数（如：K）</span></span><br><span class="line"><span class="comment">//3、数到某个数（如：M）的时候，此人出列，下一个人重新报数</span></span><br><span class="line"><span class="comment">//4、一直循环，直到所有人出列[3]  ，约瑟夫环结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">yuesefu</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node(<span class="keyword">int</span> v)</span><br><span class="line">    &#123;</span><br><span class="line">    val=v;</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N=<span class="number">9</span>;<span class="comment">//表示总个数</span></span><br><span class="line"><span class="keyword">int</span> M=<span class="number">5</span>;<span class="comment">//数到几出列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//头节点单列出来，方便形成循环链表</span></span><br><span class="line">Node t=<span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">Node x=t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立单向链表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=(x.next=<span class="keyword">new</span> Node(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个节点的next指向第一个节点，形成循环链表</span></span><br><span class="line">x.next=t;</span><br><span class="line">System.out.println(<span class="string">"依次出来的顺序为："</span>);</span><br><span class="line"><span class="keyword">while</span>(x!=x.next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;M;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=x.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(x.next.val+<span class="string">" "</span>);</span><br><span class="line">x.next=x.next.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">    System.out.println(<span class="string">"最后剩余的是： "</span>+x.val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>双向链表</strong><br><img src="/2019/02/19/链表/linkedlist3.jpg" alt="enter description here"><br>1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。<br>2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。<br>3）性能特点：<br>和单链表相比，存储相同的数据，需要消耗更多的存储空间。<br>插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。<br><strong>对于前一种情况</strong>，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。<br><strong>对于第二种情况</strong>，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。<br><em>对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</em></li><li><strong>双向循环链表：首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。</strong><h2 id="四、选择数组还是链表？"><a href="#四、选择数组还是链表？" class="headerlink" title="四、选择数组还是链表？"></a>四、选择数组还是链表？</h2></li></ul><ol><li>插入、删除和随机访问的时间复杂度<br>数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。<br>链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。</li><li>数组缺点<br>1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。<br>2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。</li><li>链表缺点<br>1）内存空间消耗更大，因为需要额外的空间存储指针信息。<br>2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。</li><li>如何选择？<br>数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。<br>如果代码对内存的使用非常苛刻，那数组就更适合。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是链表？&quot;&gt;&lt;a href=&quot;#一、什么是链表？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是链表？&quot;&gt;&lt;/a&gt;一、什么是链表？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;和数组一样，链表也是一种线性表。&lt;/li&gt;
&lt;li&gt;从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。&lt;/li&gt;
&lt;li&gt;链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.xiejiawei.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="链表" scheme="https://www.xiejiawei.cc/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://www.xiejiawei.cc/2019/02/15/%E6%95%B0%E7%BB%84/"/>
    <id>https://www.xiejiawei.cc/2019/02/15/数组/</id>
    <published>2019-02-15T04:02:16.000Z</published>
    <updated>2019-02-15T04:20:05.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><em>引文：数组看起来简单基础，但是很多人没有理解这个数据结构的精髓。带着为什么数组要从0开始编号，而不是从1开始的问题，进入主题。</em></p><h2 id="数组如何实现随机访问"><a href="#数组如何实现随机访问" class="headerlink" title="数组如何实现随机访问"></a>数组如何实现随机访问</h2><ul><li><p>数组是一种<strong>线性数据结构</strong>，用<strong>连续</strong>的存储空间存储<strong>相同类型</strong>的数据</p><a id="more"></a></li><li><p>线性表：数组、链表、队列、栈</p><p><img src="/2019/02/15/数组/array1.jpg" alt="array1"></p></li><li><p>非线性表： 树、图</p><p><img src="/2019/02/15/数组/array2.jpg" alt="array2"></p></li></ul><ol><li><p><strong>数组如何实现下标随机访问？</strong></p><p><img src="/2019/02/15/数组/array3.jpg" alt="array3"></p></li></ol><ul><li>一维数组寻址公式：<code>a[i]_address = base_address + i*data_type_size</code></li></ul><ol start="2"><li>纠正数组和链表的错误认识。数组的查找操作时间复杂度并不是O(1)。即便是有序数组，用二分查找，时间复杂度也是O(logn) . 正确表述：数组支持随机访问，根据下标随即访问的时间复杂度为O(1)。</li></ol><h2 id="低效的插入和删除"><a href="#低效的插入和删除" class="headerlink" title="低效的插入和删除"></a>低效的插入和删除</h2><ol><li><p>插入：最好O(1)【尾插】  最坏O(n) 【头插】 平均O(n)</p></li><li><p>另一种插入： 数组若无序，插入新的元素时，可以将第k个位置的元素移动到数组末尾，把新的元素插入到第k个位置，此处复杂度为 O(1)</p></li><li><p>删除：最好O(1)【尾删】  最坏O(n) 【头删】 平均O(n)</p></li><li><p>多次删除集中在一起，提高效率</p><p>记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。<strong>即JVM标记清除垃圾回收算法。</strong> </p></li></ol><h2 id="数组的访问越界问题"><a href="#数组的访问越界问题" class="headerlink" title="数组的访问越界问题"></a>数组的访问越界问题</h2><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此例在《C陷阱与缺陷》出现过：如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的 i 将会被置为0，则为死循环永远出不去。 【注】<em>64位操作系统下，编译器默认会8字节对齐。</em> 类型同为int</li></ul><h2 id="容器能否完全替代数组？"><a href="#容器能否完全替代数组？" class="headerlink" title="容器能否完全替代数组？"></a>容器能否完全替代数组？</h2><p>相比于数字，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过存储容量，扩容时比较消耗内存，因为涉及到内存申请和数据搬移。</p><p><strong>数组适合的场景：</strong></p><ol><li>Java ArrayList 的使用涉及装箱和拆箱，有一定的性能损耗，如果特别关注性能，可以考虑数组。</li><li>若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组。</li><li>表示多维数组的时候，数组往往更加直观。</li><li>业务开发容器即可，底层开发，如网络框架，性能优化。选择数组</li></ol><h2 id="解答开篇问题"><a href="#解答开篇问题" class="headerlink" title="解答开篇问题"></a>解答开篇问题</h2><ul><li>从偏移（offset）角度理解 a[0] 0 为偏移量，如果从1开始计数，会多出 k-1 。增加了一次减法运算，增加CPU负担。为什么循环要写成<code>for(int i = 0;i&lt;3;i++)</code> 而不是<code>for(int i = 0 ;i&lt;=2;i++)</code>。第一个直接就可以算出$3-0 = 3$ 有三个数据，而后者 $2-0+1$个数据，多出1个加法运算，很恼火。 </li><li>也有一定的历史原因。</li></ul><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><p><strong>三数之和</strong></p><ul><li><p>题目描述：给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如, 给定数组 nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>Ans：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>, high = nums.length-<span class="number">1</span>, sum = <span class="number">0</span> - nums[i];</span><br><span class="line">            <span class="keyword">while</span> (low&lt;high) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[low] + nums[high] == sum)&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[low],nums[high]));</span><br><span class="line">                    <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[low] == nums[low+<span class="number">1</span>]) low++;</span><br><span class="line">                    <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[high] == nums[high-<span class="number">1</span>]) high--;</span><br><span class="line">                    low++;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[low]+nums[high] &lt; sum) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;&lt;em&gt;引文：数组看起来简单基础，但是很多人没有理解这个数据结构的精髓。带着为什么数组要从0开始编号，而不是从1开始的问题，进入主题。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;数组如何实现随机访问&quot;&gt;&lt;a href=&quot;#数组如何实现随机访问&quot; class=&quot;headerlink&quot; title=&quot;数组如何实现随机访问&quot;&gt;&lt;/a&gt;数组如何实现随机访问&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数组是一种&lt;strong&gt;线性数据结构&lt;/strong&gt;，用&lt;strong&gt;连续&lt;/strong&gt;的存储空间存储&lt;strong&gt;相同类型&lt;/strong&gt;的数据&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://www.xiejiawei.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数组" scheme="https://www.xiejiawei.cc/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>算法复杂度分析</title>
    <link href="https://www.xiejiawei.cc/2019/01/22/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://www.xiejiawei.cc/2019/01/22/算法复杂度分析/</id>
    <published>2019-01-22T02:56:35.000Z</published>
    <updated>2019-01-22T04:06:14.231Z</updated>
    
    <content type="html"><![CDATA[<p>终于放寒假了，松下一口气的博主可以专心地更新博客了，希望寒假能有更大的进步！<br>本系列在于记载我的算法学习笔录，强化学习，废话不多说，开始吧。</p><hr><h1 id="什么是复杂度分析？"><a href="#什么是复杂度分析？" class="headerlink" title="什么是复杂度分析？"></a>什么是复杂度分析？</h1><ol><li>数据结构和算法解决的是“如何让计算机更快时间，更省空间的解决问题”。</li><li>因此需要从执行时间和占用空间两个维度来评估数据结构和算法的性能。</li><li>分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。 </li><li><p>复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。故称其为<strong>渐进时间（空间）复杂度</strong></p><a id="more"></a><h1 id="为什么要进行复杂度分析？"><a href="#为什么要进行复杂度分析？" class="headerlink" title="为什么要进行复杂度分析？"></a>为什么要进行复杂度分析？</h1></li><li><p>和性能测试相比，复杂度分析有不依赖环境、成本低、效率高、易操作、指导性强的特点。</p></li><li>掌握复杂度分析将能编写出性能更优秀的代码，有利于降低系统开发和维护成本</li></ol><h1 id="如何进行复杂度分析？"><a href="#如何进行复杂度分析？" class="headerlink" title="如何进行复杂度分析？"></a>如何进行复杂度分析？</h1><h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><ol><li>来源</li></ol><p>   算法的执行时间与代码的执行次数成正比，用 T(n) = O(f(n)) 表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。</p><ol start="2"><li><p>特点</p><p>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产生决定性影响。所以在做时间复杂度分析时忽略这些项。</p></li></ol><h2 id="复杂度分析法则"><a href="#复杂度分析法则" class="headerlink" title="复杂度分析法则"></a>复杂度分析法则</h2><ol><li>单段代码看高频：比如循环</li><li>多段代码取最大： 比如一段代码中有单循环和多重循环，那么取多重循环</li><li>嵌套代码求乘积：比如递归、多重循环等</li><li>多个规模求加法： 比如有两个参数控制两个循环的次数，那么就取二者复杂度相加 O(m+n)</li></ol><h1 id="常用的复杂度级别"><a href="#常用的复杂度级别" class="headerlink" title="常用的复杂度级别"></a>常用的复杂度级别</h1><p>复杂度量级：</p><p><img src="/2019/01/22/算法复杂度分析/a.jpg" alt="常用复杂度量级"></p><ul><li><p>多项式阶：随着数据规模的增大，算法的执行时间和空间占用，按照多项式的比例增长。包括：</p><p>O(1) 、O(logn)、O(n) 、O(nlogn) 、O(n^2)… O(n^k).</p></li><li><p>非多项式阶：随着数据规模的增大，算法的执行时间和空间占用暴增（NP问题），这类算法性能极差。</p><p>O(2^n) 、O(n!)</p></li></ul><p><img src="/2019/01/22/算法复杂度分析/b.jpg" alt="复杂度曲线"></p><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>首先我们要引入几个概念：<strong>最好情况时间复杂度（best case time complexity）、最坏情况时间时间按复杂度（worst case time complexity）、平均情况时间复杂度 (average case time complexity)、均摊时间复杂度(amortized time complexity)。</strong></p><h2 id="为什么要引入这4个概念？"><a href="#为什么要引入这4个概念？" class="headerlink" title="为什么要引入这4个概念？"></a>为什么要引入这4个概念？</h2><ol><li>同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。 </li><li>代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。 </li></ol><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，大小为 10 的数组 array，长度 len，下标 i。</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &gt;= len) &#123; <span class="comment">// 数组空间不够了</span></span><br><span class="line">     <span class="comment">// 重新申请一个 2 倍大小的数组空间</span></span><br><span class="line">     <span class="keyword">int</span> new_array[] = <span class="keyword">new</span> <span class="keyword">int</span>[len*<span class="number">2</span>];</span><br><span class="line">     <span class="comment">// 把原来 array 数组中的数据依次 copy 到 new_array</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">       new_array[j] = <span class="built_in">array</span>[j];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// new_array 复制给 array，array 现在大小就是 2 倍 len 了</span></span><br><span class="line">     <span class="built_in">array</span> = new_array;</span><br><span class="line">     len = <span class="number">2</span> * len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将 element 放到下标为 i 的位置，下标 i 加一</span></span><br><span class="line">   <span class="built_in">array</span>[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的最好情况时间复杂度(best case time complexity)为O(1);</p><p>最坏情况时间复杂度(worst case time complexity)为O(n); </p><p>均摊时间复杂度 (amortized time complexity) 为O(1)；</p><hr><p>以上为本篇内容，若有不足之处，请诸位多多包涵，斧正。笔者在此谢过。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于放寒假了，松下一口气的博主可以专心地更新博客了，希望寒假能有更大的进步！&lt;br&gt;本系列在于记载我的算法学习笔录，强化学习，废话不多说，开始吧。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;什么是复杂度分析？&quot;&gt;&lt;a href=&quot;#什么是复杂度分析？&quot; class=&quot;headerlink&quot; title=&quot;什么是复杂度分析？&quot;&gt;&lt;/a&gt;什么是复杂度分析？&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;数据结构和算法解决的是“如何让计算机更快时间，更省空间的解决问题”。&lt;/li&gt;
&lt;li&gt;因此需要从执行时间和占用空间两个维度来评估数据结构和算法的性能。&lt;/li&gt;
&lt;li&gt;分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。 &lt;/li&gt;
&lt;li&gt;&lt;p&gt;复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。故称其为&lt;strong&gt;渐进时间（空间）复杂度&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://www.xiejiawei.cc/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://www.xiejiawei.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据类型之Integer与int</title>
    <link href="https://www.xiejiawei.cc/2018/11/01/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BInteger%E4%B8%8Eint/"/>
    <id>https://www.xiejiawei.cc/2018/11/01/数据类型之Integer与int/</id>
    <published>2018-11-01T12:05:08.000Z</published>
    <updated>2018-11-08T11:10:44.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>  众所周知，Java是面向对象的语言，一切皆对象。但是为了兼容人类根深蒂固的数据处理习惯，加快常规数据的处理速度，提供了9种<strong>基本数据类型</strong>，他们都不具备对象的特性，没有属性和行为。Java的9种基本数据类型包括 boolean、byte、char、short、int、long、double和refvar。前8种数据类型表示生活中的真假、字符、整数和小数，最后一种refvar是面向对象世界中的引用变量，也叫引用句柄。<em>此处认为它也是一种基本数据类型。</em><br>  前8种都有其对应的包装数据类型，除了char的对应包装类名为 Character， int为 Integer外，其它所有对应的包装类名就是把首字母大写即可。<br>  <a id="more"></a><br>  <strong>下面列出了这8种基本数据类型的空间占用大小(bit)及对应的包装类等信息。</strong></p><ul><li>boolean/1/Boolean<ul><li>byte/8/Byte</li><li>char/16/Character</li><li>short/16/Short</li><li>int/32/Integer</li><li>float/32/Float</li><li>long/64/Long</li><li>double/64/Double</li></ul></li></ul><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>前8种基本数据类型都有相应的包装类，因为Java的设计理念是一切皆是对象，在很多情况下，需要以对象的形式操作，比如hashCode()获取哈希值，或者getClass获取类等。包装类的存在解决了基本数据类型无法做到的事情：泛型类型参数、序列化、类型转换、高频区间数据缓存。<br>重点要说的就是最后一项：<strong>缓存池</strong></p><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>事实上除了Float和Double外，其他包装类型都会缓存。接下来我以介绍Integer的方式来讲解缓存。<br>先看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer.valueOf(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><p>valueOf() 方法的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上源代码，赋值数据i在缓存区间内直接返回缓存池中的Integer对象，否则就会new一个对象。<br>因此比较时会出现如下问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        Integer i3 = <span class="number">500</span>;</span><br><span class="line">        Integer i4 = <span class="number">500</span>;</span><br><span class="line">        System.out.println(i3 == i4);</span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">        System.out.println(i3.equals(i4));</span><br><span class="line">        <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>所以推荐所有包装类型对象之间的比较，全部使用equals方法。</em></p><p>  在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> j = low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>相关参考：<br><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123" target="_blank" rel="noopener">StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h2&gt;&lt;p&gt;  众所周知，Java是面向对象的语言，一切皆对象。但是为了兼容人类根深蒂固的数据处理习惯，加快常规数据的处理速度，提供了9种&lt;strong&gt;基本数据类型&lt;/strong&gt;，他们都不具备对象的特性，没有属性和行为。Java的9种基本数据类型包括 boolean、byte、char、short、int、long、double和refvar。前8种数据类型表示生活中的真假、字符、整数和小数，最后一种refvar是面向对象世界中的引用变量，也叫引用句柄。&lt;em&gt;此处认为它也是一种基本数据类型。&lt;/em&gt;&lt;br&gt;  前8种都有其对应的包装数据类型，除了char的对应包装类名为 Character， int为 Integer外，其它所有对应的包装类名就是把首字母大写即可。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.xiejiawei.cc/categories/Java/"/>
    
    
      <category term="Java入门" scheme="https://www.xiejiawei.cc/tags/Java%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>python漫谈-0</title>
    <link href="https://www.xiejiawei.cc/2018/10/06/python-talk-0/"/>
    <id>https://www.xiejiawei.cc/2018/10/06/python-talk-0/</id>
    <published>2018-10-06T03:06:02.000Z</published>
    <updated>2018-10-06T05:19:32.386Z</updated>
    
    <content type="html"><![CDATA[<p>​                                                                     <a href="//www.zhihu.com/people/a-kun-99-10"><img src="/2018/10/06/python-talk-0/avatar.jpg" alt="Mikejiawei"></a></p><p>Hello,又和大家见面了。最近国庆放假终于可以腾开手写我的博客啦！ ^_^!</p><hr><p>​    <strong>Python 漫谈系列</strong> 是笔者对于过往 python 学习的总结和对新知识的记录。这个系列将见证本人的成长，<em>希望能一直保持更新</em></p><a id="more"></a><p>废话说完了，现在开始正文。</p><p>​    <a href="https://www.python.org/" title="Python" target="_blank" rel="noopener">Python</a> 是一门脚本语言，详见官方文档。它的应用范围十分广泛，涉足<strong>Web应用开发</strong>，<strong>系统网络运维</strong>，<strong>科学与数字运算</strong>，<strong>3D游戏开发</strong>，<strong>网络编程</strong>，等等。足见其灵活性与强大性。</p><p>​    由此可见，python 不局限于一个简单的脚本，或者写一个爬虫，文件处理。它有许多神奇等着我们去挖掘！本篇为开篇，简单介绍一下 <strong>Python</strong> 的变量和字符串。</p><hr><p>【注】</p><ul><li><p><em>此系列主要是总结，会结合一些案例与题目。</em> </p></li><li><p><a href="https://docs.python.org/3/library/idle.html" title="IDLE" target="_blank" rel="noopener">IDLE</a></p></li></ul><hr><h1 id="python中的变量"><a href="#python中的变量" class="headerlink" title="python中的变量"></a>python中的变量</h1><h2 id="python数据类型"><a href="#python数据类型" class="headerlink" title="python数据类型"></a>python数据类型</h2><p>说到<strong>python</strong>中的常量，不得不说它的<strong>数据类型</strong>，其分为 哈希类型、不可哈希类型。</p><p><strong>哈希类型</strong>，即在原地不能改变的变量类型，不可变类型。可利用hash函数查看器hash值，也可以作为字典的key   </p><ul><li>“ 数字类型 ： int, float, decimal.Decimal, fractions.Fraction, complex “</li><li>“ 字符串类型 ：str, bytes  “</li><li>“ 元组 ：tuple  “</li><li>“ 冻结集合 ：frozenset “</li><li>“ 布尔类型 ：True，False “</li><li>“ None “</li></ul><p><strong>不可哈希类型</strong>，原地可变类型：list、dict 和 set，它们不可以作为字典的key。</p><h2 id="python中的变量-1"><a href="#python中的变量-1" class="headerlink" title="python中的变量"></a>python中的变量</h2><p>接触过其它语言的人都知道，把一个值赋值给一个变量名时，Ta会存储在内存中，我们称其为变量。在大多数语言当中，都把这种行为称作“给变量赋值”。</p><p>不过 Python 与大多数其它计算机语言的做法稍有不同， Ta并不是把值储存在变量中， 而更像是把名字贴在值的上边，<strong>接触过C/C++的知道这其实是指针</strong></p><p><strong>举个栗子</strong></p><blockquote><p><code>int</code> 类型在python中是动态长度的。因为python3中 int 类型是长整型，理论支持无限大的数字，但它的结构其实也很简单, 在 <code>longintepr.h</code> 中定义： </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct _longobject &#123;</span><br><span class="line">  PyObject_VAR_HEAD</span><br><span class="line">  digi ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这结构是什么意思呢，重点在于 <code>ob_digit</code> 它是一个数组指针。<code>digit</code> 可认为是 <code>int</code> 的别名。python的整型存储机制是这样的。比方要表示一个很大的数: <code>123456789</code> 。而每个元素最大只能表示3位十进制数（为理解打的比方）。那么python就会这样存储：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ob_digit[<span class="number">0</span>] = <span class="number">789</span></span><br><span class="line">ob_digit[<span class="number">1</span>] = <span class="number">456</span></span><br><span class="line">ob_digit[<span class="number">2</span>] = <span class="number">123</span></span><br></pre></td></tr></table></figure><h1 id="Python-中的字符串"><a href="#Python-中的字符串" class="headerlink" title="Python 中的字符串"></a>Python 中的字符串</h1><ul><li><p>例子：<strong>试试直接输入 &gt;&gt;&gt;5+8 与输入 &gt;&gt;&gt;print(5+8) 有何不同？</strong>  </p><p>不妨试试直接直接输入 &gt;&gt;&gt;’I love python!’ 与输入 &gt;&gt;&gt;print(‘I love python!’) 有何不同？ 没错，直接输入是将结果及类型打印到屏幕上，而print是将结果打印到屏幕上。</p></li></ul><p>没错python中的字符串是一个比较有意思的东西，举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#常见字符串常量和表达式</span></span><br><span class="line">S = <span class="string">''</span><span class="comment"># 空字符串</span></span><br><span class="line">S = <span class="string">" spam's "</span><span class="comment"># 双引号 和单引号相同</span></span><br><span class="line">S = <span class="string">"s\np\ta\x00m"</span>  <span class="comment"># 转义字符</span></span><br><span class="line">S = <span class="string">r'\temp'</span><span class="comment">#raw字符串，抑制转义，但是末尾不能+\</span></span><br><span class="line"><span class="comment">#如果要在末尾加\ 可以选择拼接一个 ^-^!</span></span><br><span class="line">S = <span class="string">b'Spam'</span><span class="comment">#Python3 中的字节字符串</span></span><br><span class="line">s1+s2, s1*<span class="number">3</span>, s[i], s[i:j], len(s) <span class="comment">#字符串操作</span></span><br><span class="line"><span class="comment">#另类字符串拼接</span></span><br><span class="line">name = <span class="string">"da"</span><span class="string">"han"</span><span class="comment">#单行， name = "dahan"</span></span><br><span class="line">name = <span class="string">"da"</span> \<span class="comment">#多行， name = "dahan"</span></span><br><span class="line"><span class="string">"han"</span></span><br><span class="line"><span class="comment">#多行字符串块</span></span><br><span class="line">m = <span class="string">"""hello world</span></span><br><span class="line"><span class="string">   hello html</span></span><br><span class="line"><span class="string">   hello python</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p><strong>其实python中的字符串妙用和功能还有很多，这里这是浅显的介绍一下，以后在项目中我会有所体现的哦！</strong></p><hr><ul><li>因为笔者是初学者尚有许多不足，欢迎各位观众姥爷批评指正。</li><li>希望此系列能越写越好 QAQ</li></ul><p><img src="/2018/10/06/python-talk-0/python.png" alt="python"></p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​                                                                     &lt;a href=&quot;//www.zhihu.com/people/a-kun-99-10&quot;&gt;&lt;img src=&quot;/2018/10/06/python-talk-0/avatar.jpg&quot; alt=&quot;Mikejiawei&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hello,又和大家见面了。最近国庆放假终于可以腾开手写我的博客啦！ ^_^!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;​    &lt;strong&gt;Python 漫谈系列&lt;/strong&gt; 是笔者对于过往 python 学习的总结和对新知识的记录。这个系列将见证本人的成长，&lt;em&gt;希望能一直保持更新&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python学习" scheme="https://www.xiejiawei.cc/categories/python%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="https://www.xiejiawei.cc/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>三种常用的排序算法</title>
    <link href="https://www.xiejiawei.cc/2018/08/21/%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://www.xiejiawei.cc/2018/08/21/三种常用的排序算法/</id>
    <published>2018-08-20T16:22:53.000Z</published>
    <updated>2018-11-01T02:58:34.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三种常用的排序算法"><a href="#三种常用的排序算法" class="headerlink" title="三种常用的排序算法"></a>三种常用的排序算法</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><em>笔者</em> 是一名在校大学生，在学校常用的算法有很多，<strong>毕竟算法是程序的灵魂</strong> ，我就整理一点算法笔记放在博客上以供参考。<em>PS: Java版本</em></p><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul><li>平均时间复杂度：O(n^2)</li><li>稳定性：稳定[^1]</li><li><p>排序算法的稳定性(<em>腾讯校招2016笔试题曾考过</em>)</p><blockquote><p>冒泡排序是一种极其简单的排序算法，也是我所学的第一个排序算法。它重复地走访过要排序的元素，依此比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。 </p></blockquote><p><strong>代码如下</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义临时变量</span></span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++)&#123; <span class="comment">//对n个数排序只要交换n-1次即可</span></span><br><span class="line">            <span class="comment">//外层循环，每次把最大的元素像气泡一样“浮”到数组的最后</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt;arr.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//内层循环</span></span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123; <span class="comment">//依此比较相邻的两个元素，使较大的那个向后移</span></span><br><span class="line"><span class="comment">//三变量交换法</span></span><br><span class="line">                      p = arr[j];</span><br><span class="line">arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>] = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">28</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">bubbleSort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果如下</strong> </p><blockquote><p>[1, 3, 4, 5, 6, 7, 7, 8, 28]</p><a id="more"></a></blockquote></li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li><p>平均时间复杂度：O(n^2)</p></li><li><p>稳定性：不稳定</p><blockquote><p>选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>　　注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。</p></blockquote><p><strong>代码如下：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">//i 为已排序序列的末尾 </span></span><br><span class="line">             <span class="keyword">int</span> k = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j= i+<span class="number">1</span>;j&lt;arr.length;j++) &#123;<span class="comment">//未排序序列</span></span><br><span class="line"><span class="keyword">if</span> (arr[k]&gt;arr[j]) &#123;<span class="comment">//找出未排序序列中的最小值</span></span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i!=k) &#123;<span class="comment">//放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[k];</span><br><span class="line">arr[k] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[ ] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">28</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">selectionSort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果如下：</strong> </p><blockquote><p>[1, 3, 4, 5, 6, 7, 8, 11, 28]</p></blockquote></li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li><p>平均时间复杂度：O(nlogn)</p></li><li><p>稳定性：不稳定</p></li><li><p><strong>快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。</strong> </p><blockquote><p>​    快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlog n)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlog n) 算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。</p><p>　　快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：</p><ol><li>从序列中挑出一个元素，作为”基准”(pivot).</li><li>把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。</li><li>对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。</li></ol></blockquote></li></ul><p><strong>快速排序的代码如下：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快速排序的递归版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大等于endIndex的时候</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分递归排序</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取第一个位置的元素作为基准元素</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="comment">//控制right指针比较并左移</span></span><br><span class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//控制left指针比较并右移</span></span><br><span class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换left和right指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = arr[left];</span><br><span class="line">                arr[left]  = arr[right];</span><br><span class="line">                arr[right] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pivot和指针重合点交换</span></span><br><span class="line">        <span class="keyword">int</span> p = arr[left];</span><br><span class="line">        arr[left]  = arr[startIndex];</span><br><span class="line">        arr[startIndex] = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">28</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果如下：</strong></p><blockquote><p>[1, 3, 4, 5, 6, 7, 7, 8, 28]</p></blockquote><ul><li><p><strong>快速排序的非递归实现：</strong></p><blockquote><p>绝大多数用递归来实现的问题，都可以用【栈】的方式来代替。</p><p>因为我们代码中一层一层的方法调用，本身就是一个函数栈。每次进入一个新方法，就相当于入栈；每次有方法返回，就相当于出栈。</p><p>所以，我们可以把原本的递归实现转化成一个栈的实现，在栈当中存储每一次方法调用的参数。</p></blockquote><p>  <strong>代码如下：</strong> </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSortWithStack</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//  用一个集合栈来代替递归的函数栈</span></span><br><span class="line">        Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="keyword">new</span> Stack&lt;Map&lt;String, Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">//  整个数列的起止下标，以哈希的形式入栈</span></span><br><span class="line">        Map rootParam = <span class="keyword">new</span> HashMap();</span><br><span class="line">        rootParam.put(<span class="string">"startIndex"</span>, startIndex);</span><br><span class="line">        rootParam.put(<span class="string">"endIndex"</span>, endIndex);</span><br><span class="line">        quickSortStack.push(rootParam);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环结束条件： 栈为空时结束</span></span><br><span class="line">        <span class="keyword">while</span>(!quickSortStack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//栈顶元素出栈，得到起止下标</span></span><br><span class="line">            Map&lt;String, Integer&gt; param = quickSortStack.pop();</span><br><span class="line">            <span class="comment">//得到基准元素位置</span></span><br><span class="line">            <span class="keyword">int</span> pivotIndex  = partition(arr, param.get(<span class="string">"startIndex"</span>), param.get(<span class="string">"endIndex"</span>));</span><br><span class="line">            <span class="comment">//根据基准元素分成两部分，把每一部分的起止下标入栈</span></span><br><span class="line">            <span class="keyword">if</span> (param.get(<span class="string">"startIndex"</span>)&lt; pivotIndex -<span class="number">1</span>) &#123;</span><br><span class="line">                Map&lt;String, Integer&gt; leftParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">                leftParam.put(<span class="string">"startIndex"</span>, param.get(<span class="string">"startIndex"</span>));</span><br><span class="line">                leftParam.put(<span class="string">"endIndex"</span>, pivotIndex -<span class="number">1</span>);</span><br><span class="line">                quickSortStack.push(leftParam);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pivotIndex + <span class="number">1</span> &lt; param.get(<span class="string">"endIndex"</span>)) &#123;</span><br><span class="line">                Map&lt;String, Integer&gt; rightParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">                rightParam.put(<span class="string">"startIndex"</span>, pivotIndex + <span class="number">1</span>);</span><br><span class="line">                rightParam.put(<span class="string">"endIndex"</span>, param.get(<span class="string">"endIndex"</span>));</span><br><span class="line">                quickSortStack.push(rightParam);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取第一个位置的元素作为基准元素</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> left = startIndex;</span><br><span class="line">        <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="comment">//控制right指针比较并左移</span></span><br><span class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//控制left指针比较并右移</span></span><br><span class="line">            <span class="keyword">while</span> (left&lt;right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换left和right指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = arr[left];</span><br><span class="line">                arr[left]  = arr[right];</span><br><span class="line">                arr[right] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pivot和指针重合点交换</span></span><br><span class="line">        <span class="keyword">int</span> p = arr[left];</span><br><span class="line">        arr[left]  = arr[startIndex];</span><br><span class="line">        arr[startIndex] = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>运行结果如下：</strong></p><blockquote><p>[1, 2, 3, 4, 5, 6, 7, 8]</p></blockquote></li></ul><pre><code>---## 结语：emmm，常用的排序算法就介绍到这里，如有错漏之处，或者有疑问可联系笔者，愿一起进步。Email： 15270013718@163.com</code></pre><p>  [^1]: <strong>如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。</strong>  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;三种常用的排序算法&quot;&gt;&lt;a href=&quot;#三种常用的排序算法&quot; class=&quot;headerlink&quot; title=&quot;三种常用的排序算法&quot;&gt;&lt;/a&gt;三种常用的排序算法&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;em&gt;笔者&lt;/em&gt; 是一名在校大学生，在学校常用的算法有很多，&lt;strong&gt;毕竟算法是程序的灵魂&lt;/strong&gt; ，我就整理一点算法笔记放在博客上以供参考。&lt;em&gt;PS: Java版本&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;平均时间复杂度：O(n^2)&lt;/li&gt;
&lt;li&gt;稳定性：稳定[^1]&lt;/li&gt;
&lt;li&gt;&lt;p&gt;排序算法的稳定性(&lt;em&gt;腾讯校招2016笔试题曾考过&lt;/em&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;冒泡排序是一种极其简单的排序算法，也是我所学的第一个排序算法。它重复地走访过要排序的元素，依此比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;代码如下&lt;/strong&gt; &lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.Arrays;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BubbleSort&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bubbleSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//定义临时变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;arr.length-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i++)&amp;#123; &lt;span class=&quot;comment&quot;&gt;//对n个数排序只要交换n-1次即可&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//外层循环，每次把最大的元素像气泡一样“浮”到数组的最后&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j&amp;lt;arr.length-i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//内层循环&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(arr[j]&amp;gt;arr[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&amp;#123; &lt;span class=&quot;comment&quot;&gt;//依此比较相邻的两个元素，使较大的那个向后移&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&lt;span class=&quot;comment&quot;&gt;//三变量交换法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      p = arr[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					arr[j] = arr[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					arr[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] &amp;#123;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		bubbleSort(arr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(Arrays.toString(arr));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;运行结果如下&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[1, 3, 4, 5, 6, 7, 7, 8, 28]&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://www.xiejiawei.cc/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://www.xiejiawei.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java入门" scheme="https://www.xiejiawei.cc/tags/Java%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>类与对象</title>
    <link href="https://www.xiejiawei.cc/2018/06/05/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.xiejiawei.cc/2018/06/05/类与对象/</id>
    <published>2018-06-04T16:54:47.000Z</published>
    <updated>2018-11-01T03:27:04.222Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p9vujz2kq.bkt.clouddn.com/01title.jpg" alt=" "></p><h1 id="当大一萌新遇上Java系列——浅谈Java中的类与对象"><a href="#当大一萌新遇上Java系列——浅谈Java中的类与对象" class="headerlink" title="当大一萌新遇上Java系列——浅谈Java中的类与对象"></a>当大一萌新遇上Java系列——浅谈Java中的类与对象</h1><p><a href="//www.zhihu.com/people/a-kun-99-10">Mikejiawei</a></p><p>笔者是一名大一新生，虽久闻Java大名，却不识庐山真面目，最近才开始接触Java这门语言。</p><ul><li>Java作为一种流行的语言，自有其可取之处，毕竟它有可以跨平台运行的优点，被众多厂商支持，以及拥有众多的开发工具。</li></ul><p>当然作为一个程序猿吐槽自己用的语言是常见的消遣方式?,例如</p><blockquote><p>JAVA truly is the great equalizing software. It has reduced all computers to mediocrity and buggyness. - NASA’s J-Track web site（Java是一个真正注重平等权的软件，它将所有的电脑（不管配置有多好）统统变成平庸的以及有bug的电脑。- NASA’s J-Track web site）<br>Whenever I write code in Java I feel like I’m filling out endless forms in triplicate. – Joe Marshall (aka jrm)（每当我在Java中写代码时，我都觉得我在填写一式三份的表格 – Joe Marshall）</p></blockquote><p>言归正传，Java作为一种面向对象的语言，顾名思义就是把构成问题事物分解成各个对象，并描述对象在解决整个问题的步骤中的状态和行为。这与C等面向过程的语言不同，有着不同的解决问题的方式。今天我们谈的是java中的“类与对象”。<br><a id="more"></a></p><p>以下正文</p><hr><ul><li><strong>如何理解“类与对象”</strong></li></ul><p>“类”就是一类事物，是某些有相同特性的事物的集合、总称；例如人类，鱼类，鸟类等。</p><p>”对象“指的是”这一类事物中具体的一个东西“，如一个叫李四的人就是人类中的一个对象，学生李就是学生类中的一个对象，由此可见”类“是一个较为抽象，笼统的概念，对象则更为具体。</p><p>在这里大概有人会问了：</p><p>Q：电子产品类里，手机是其中一个对象，但手机也有很多种，那手机是类还是对象呢？</p><p>A：在电子产品类中，手机是一个对象。当然手机也可以是一个手机类，包括了华为手机，苹果手机这些手机对象。所以类与对象其实是个相对的关系，理解这一点，对以后我们学习继承，接口，理解子父类有很大帮助。（嘿嘿嘿~）</p><p><em><strong>PS:在现实生活中我们可以根据不同的场景来编写不同的类以解决问题，比如你要给你的朋友写个关于空调的程序，那就建一个空调类，在运用海尔，美的空调等对象。</strong></em></p><ul><li><strong>格式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">drawPanel</span></span>&#123;</span><br><span class="line">    MyFrame drawFrame = <span class="keyword">new</span> MyFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意具体格式来了：</li></ul><p>public class 类名{</p><p>类名 对象名 = new 类名( );</p><p>}</p><p>注意括号和分号都要用英文格式，不然会报错。</p><ul><li><strong>属性和方法</strong></li></ul><p>大家发现，上图中除了类与对象还有一些其他的东西，那就是属性和方法。</p><p>“属性”就是类所具备的特征，比如学生类具有”姓名，班级，学分，年龄“等各种各样的属性。</p><p>”方法“就是对象需要执行的动作，比如”学习，吃饭，睡觉，运动“。</p><ul><li>属性和方法的格式</li></ul><p>属性：</p><p>public 数据类型 数据名；</p><p>如public String name；</p><p>上面指的的数据类型有：整形，浮点型（小数），字符串等等；有其对应的英文比如：整数（int），小数（float）。</p><p>方法：</p><p>pubic void 方法名（参数）{</p><p>方法体</p><p>}</p><ul><li>结束语</li></ul><p><em>欢迎各位从入门到入土的Java工程师们和小伙伴们留言，一起交流学习，文中有错漏之处也欢迎批评指出，人生不能没有bug嘛（哈哈~）</em></p><p><em>希望在这条道路上越走越远，下次再见ヾ(￣▽￣)Bye~Bye~</em></p><p><img src="http://p9vujz2kq.bkt.clouddn.com/01avatar.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://p9vujz2kq.bkt.clouddn.com/01title.jpg&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;当大一萌新遇上Java系列——浅谈Java中的类与对象&quot;&gt;&lt;a href=&quot;#当大一萌新遇上Java系列——浅谈Java中的类与对象&quot; class=&quot;headerlink&quot; title=&quot;当大一萌新遇上Java系列——浅谈Java中的类与对象&quot;&gt;&lt;/a&gt;当大一萌新遇上Java系列——浅谈Java中的类与对象&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;//www.zhihu.com/people/a-kun-99-10&quot;&gt;Mikejiawei&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;笔者是一名大一新生，虽久闻Java大名，却不识庐山真面目，最近才开始接触Java这门语言。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java作为一种流行的语言，自有其可取之处，毕竟它有可以跨平台运行的优点，被众多厂商支持，以及拥有众多的开发工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然作为一个程序猿吐槽自己用的语言是常见的消遣方式?,例如&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JAVA truly is the great equalizing software. It has reduced all computers to mediocrity and buggyness. - NASA’s J-Track web site（Java是一个真正注重平等权的软件，它将所有的电脑（不管配置有多好）统统变成平庸的以及有bug的电脑。- NASA’s J-Track web site）&lt;br&gt;Whenever I write code in Java I feel like I’m filling out endless forms in triplicate. – Joe Marshall (aka jrm)（每当我在Java中写代码时，我都觉得我在填写一式三份的表格 – Joe Marshall）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;言归正传，Java作为一种面向对象的语言，顾名思义就是把构成问题事物分解成各个对象，并描述对象在解决整个问题的步骤中的状态和行为。这与C等面向过程的语言不同，有着不同的解决问题的方式。今天我们谈的是java中的“类与对象”。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.xiejiawei.cc/categories/Java/"/>
    
    
      <category term="Java入门" scheme="https://www.xiejiawei.cc/tags/Java%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
